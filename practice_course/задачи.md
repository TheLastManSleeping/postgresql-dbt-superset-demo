# Сборник задач по dbt

Этот документ содержит набор практических заданий для самостоятельной работы.

---

## Уровень 1: Основы и Staging

На этом этапе мы практикуемся подключаться к данным, создавать базовые модели, добавлять тесты и документацию.

### Задача 1.1: Объявление источника
"Расскажите" dbt, где лежат ваши сырые данные.
1.  Создайте файл `models/staging/schema.yml`.
2.  Внутри него опишите ваш `source` (источник). Дайте ему имя `raw_data`, укажите схему в Postgres (`public`) и имя таблицы (`yellow_tripdata_2024_01`).

### Задача 1.2: Первая стейджинг-модель
Создайте "очищенную" версию сырых данных.
1.  Создайте файл `models/staging/stg_yellow_tripdata.sql`.
2.  Напишите `SELECT` запрос к вашему источнику, используя функцию `{{ source(...) }}`.
3.  Переименуйте все ключевые столбцы в `snake_case` (например, `tpep_pickup_datetime` -> `pickup_datetime`, `"PULocationID"` -> `pickup_location_id`).
4.  Выполните базовое приведение типов для столбцов (`::timestamp` для дат, `::integer` для `passenger_count`).

### Задача 1.3: Настройка материализации
Явно укажите dbt, как создавать стейджинг-модель.
1.  В файле `models/staging/stg_yellow_tripdata.sql` добавьте блок `config` вверху.
2.  Укажите в нем, что эта модель должна материализоваться как `view`.

### Задача 1.4: Добавление базовых тестов
Убедитесь в базовом качестве данных.
1.  В файле `models/staging/schema.yml` опишите вашу модель `stg_yellow_tripdata`.
2.  Добавьте `not_null` тесты на столбцы `pickup_datetime` и `dropoff_datetime`.
3.  Добавьте тест `accepted_values` на столбец `payment_type`, чтобы он принимал только значения `[1, 2, 3, 4]`.

### Задача 1.5: Добавление документации
Сделайте ваш проект понятным для коллег.
1.  В файле `models/staging/schema.yml` добавьте `description` (описание) для модели `stg_yellow_tripdata`.
2.  Добавьте описания для 3-4 ключевых столбцов (например, `total_amount`, `trip_distance`).

### Задача 1.6: Запуск и проверка
Убедитесь, что все работает.
1.  Выполните команду `docker compose exec dbt dbt run`, чтобы создать вашу модель.
2.  Выполните команду `docker compose exec dbt dbt test`, чтобы проверить данные.
3.  Выполните `docker compose exec dbt dbt docs generate` и `docker compose exec dbt dbt docs serve`, чтобы запустить сайт с документацией и изучить ваш граф (DAG).

---

## Уровень 2: Трансформации и витрины (Marts)

На этом этапе мы создаем модели с бизнес-логикой, объединяем данные и начинаем использовать `ref`.

### Задача 2.1: Создание витрины фактов (Fact Table)
Создайте модель `fct_trips.sql` в новой папке `models/marts/`. Эта модель должна ссылаться на `stg_yellow_tripdata` с помощью функции `{{ ref(...) }}`.
1.  В этой модели добавьте новые расчетные столбцы:
    * `duration_minutes`: Длительность поездки в минутах.
    * `average_speed_mph`: Средняя скорость (мили в час).
    * **(Сложность)**: Обработайте случаи, когда длительность поездки равна нулю, чтобы избежать деления на ноль.
2.  Материализуйте эту модель как `table`.

### Задача 2.2: Создание справочника (Seed)
Часто справочники хранятся в CSV. Давайте создадим такой.
1.  Создайте в папке `seeds/` файл `payment_type_lookup.csv`.
2.  Наполните его данными:
    ```csv
    id,payment_type_name
    1,Credit card
    2,Cash
    3,No charge
    4,Dispute
    ```
3.  Выполните команду `dbt seed`, чтобы загрузить этот справочник в базу данных.

### Задача 2.3: Присоединение справочника (JOIN)
Обогатите вашу витрину `fct_trips` понятными названиями.
1.  Измените модель `fct_trips.sql`.
2.  Добавьте `LEFT JOIN` к справочнику `payment_type_lookup` (используя `{{ ref(...) }}`), чтобы добавить столбец `payment_type_name`.

### Задача 2.4: Кастомный тест (Singular Test)
Напишите собственный SQL-тест для проверки бизнес-логики.
1.  Создайте файл `tests/assert_trip_duration_is_positive.sql`.
2.  Напишите в нем SQL-запрос, который находит все записи в `fct_trips`, где `duration_minutes < 0`. (Тест пройдет, если запрос вернет 0 строк).
3.  Запустите `dbt test`.

### Задача 2.5: Тест на ссылочную целостность
Убедитесь, что все ID в таблице фактов существуют в справочнике.
1.  В файле `models/marts/schema.yml` (создайте его) опишите модель `fct_trips`.
2.  Добавьте `relationships` тест на столбец `payment_type`, чтобы он ссылался на столбец `id` в модели `payment_type_lookup`.

---

## Уровень 3: Продвинутые возможности

Здесь мы знакомимся с макросами, инкрементальными моделями и более сложными тестами.

### Задача 3.1: Создание макроса
Избегайте дублирования кода.
1.  Создайте файл `macros/calculate_tip_percentage.sql`.
2.  Напишите в нем макрос с именем `calculate_tip_percentage`, который принимает два аргумента: `tip_amount` и `fare_amount`.
3.  Макрос должен возвращать процент чаевых. Он также должен безопасно обрабатывать случаи, когда `fare_amount` равен 0 (в этом случае возвращать 0).

### Задача 3.2: Использование макроса
Примените ваш макрос.
1.  Отредактируйте модель `fct_trips.sql`.
2.  Добавьте новый столбец `tip_percentage`, используя ваш макрос `{{ calculate_tip_percentage(...) }}`.

### Задача 3.3: Пакет `dbt-expectations`
Используйте готовые тесты сообщества для более глубокой проверки данных.
1.  Создайте файл `packages.yml` в корне проекта.
2.  Добавьте в него пакет `dbt-labs/dbt_expectations` (или `calogica/dbt_expectations` в зависимости от версии).
3.  Выполните `dbt deps`.
4.  В файле `models/marts/schema.yml` добавьте тесты из этого пакета к модели `fct_trips`:
    * `expect_column_values_to_be_between` для `total_amount`, чтобы проверить, что 99% поездок стоят от 0 до 1000.
    * `expect_column_mean_to_be_between` для `tip_amount`, чтобы проверить, что средние чаевые находятся в разумном диапазоне (например, от 2 до 10).

### Задача 3.4: Инкрементальная модель
Научитесь работать с большими данными, которые обновляются.
1.  Скопируйте вашу `fct_trips` в новую модель `fct_trips_incremental.sql`.
2.  Измените ее `config`: материализация `incremental`.
3.  Добавьте в SQL-запрос логику `{% if is_incremental() %}`.
4.  Внутри этого блока добавьте условие `WHERE`, которое будет отбирать только те записи, где `pickup_datetime` больше, чем максимальный `pickup_datetime` из уже существующей таблицы `{{ this }}`.

### Задача 3.5: Снэпшоты (Snapshots)
Научитесь отслеживать изменения в справочниках (SCD Type 2).
1.  Предположим, что наш справочник `payment_type_lookup` может меняться (например, "Dispute" переименуют в "Refunded").
2.  Создайте папку `snapshots/`.
3.  Создайте в ней файл `snapshot_payment_types.sql`.
4.  Напишите снэпшот, который будет следить за `{{ ref('payment_type_lookup') }}`.
5.  Используйте `strategy='check'` и укажите `check_cols=['payment_type_name']`.
6.  Запустите `dbt snapshot`.

---

## Уровень 4: Бонусные и творческие задачи


### Задача 4.1: Создание аналитической витрины
Подготовьте данные для BI-инструмента.
1.  Создайте модель `models/analytics/daily_summary.sql`.
2.  В ней, используя `fct_trips`, рассчитайте для каждого дня (`date_trunc('day', pickup_datetime)`) следующие показатели:
    * `total_trips` (общее кол-во поездок)
    * `total_passengers` (всего пассажиров)
    * `total_fare_amount` (общая сумма по счетчику)
    * `average_duration_minutes` (средняя длительность поездки)
    * `average_tip_percentage` (средний % чаевых)

### Задача 4.2: Сложный макрос с циклом
Проверьте свои навыки в Jinja.
1.  Создайте макрос `get_payment_type_columns()`.
2.  Макрос должен возвращать SQL-код, который "разворачивает" (PIVOT) типы оплат в столбцы. Примерно так:
    ```sql
    sum(case when payment_type = 1 then total_amount else 0 end) as amount_credit_card,
    sum(case when payment_type = 2 then total_amount else 0 end) as amount_cash,
    ...
    ```
3.  Используйте этот макрос в модели `daily_summary.sql`, чтобы добавить в нее столбцы с суммарной выручкой по каждому типу оплаты.

### Задача 4.3: Оптимизация проекта
Наведите порядок.
1.  Создайте промежуточную (intermediate) модель в `models/intermediate/`, которая объединяет `stg_yellow_tripdata` и `payment_type_lookup`.
2.  Переделайте `fct_trips` так, чтобы она читала данные из этой промежуточной модели, а не делала `JOIN` самостоятельно.
3.  Используйте `dbt run --select +fct_trips`, чтобы убедиться, что dbt понимает новую зависимость и перестраивает все по цепочке.