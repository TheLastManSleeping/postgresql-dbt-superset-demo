# Модуль 2: Основы основ — Модели и Источники

На этом этапе мы создадим нашу первую dbt-модель. Мы научим dbt находить "сырые" данные и преобразовывать их в новый, более чистый и удобный для работы вид. Это фундаментальный рабочий процесс в dbt.

---

## Теория

### 1. Источники (`sources`)

**Источники** — это способ объявить в dbt-проекте, что вы используете таблицы, которые не были созданы самим dbt. Это "входные ворота" для ваших сырых данных.

* **Зачем это нужно?** Вместо того чтобы писать в коде `select * from raw_schema.my_table`, вы объявляете источник один раз в `.yml` файле и затем ссылаетесь на него с помощью функции `source()`. Это позволяет dbt отслеживать зависимости от сырых данных и проверять их актуальность.
* **Аналогия:** Представьте, что источник — это "ярлык" или "бирка", которую вы вешаете на вашу исходную таблицу в базе данных, чтобы dbt знал ее по имени.

### 2. Модели (`models`)

**Модель** в dbt — это всего лишь один SQL-файл с `SELECT` запросом. Каждый `.sql` файл в папке `models/` является одной моделью.

* **Результат:** Когда вы запускаете `dbt run`, dbt выполняет этот `SELECT` запрос и сохраняет его результаты в вашей базе данных в виде таблицы или представления.
* **Имя модели:** Имя файла (`my_model.sql`) становится именем таблицы/представления в базе данных.

### 3. Функции `source()` и `ref()`

Это две самые важные функции в dbt, которые позволяют создавать граф зависимостей (DAG).

* `{{ source('source_name', 'table_name') }}`: Используется для **чтения из сырых данных**, которые вы объявили в `.yml` файле. **Применяется только на первом, "стейджинг" слое.**
* `{{ ref('model_name') }}`: Используется для **чтения из другой dbt-модели**. Это "клей", который соединяет ваши модели в единый конвейер.

**Золотое правило:** Вы используете `source` один раз, чтобы забрать сырые данные. Во всех последующих моделях вы ссылаетесь на другие модели только через `ref`.



### 4. Материализации

**Материализация** — это то, как dbt будет сохранять результаты вашей модели в базе данных. Основные типы:

* **`view`** (по умолчанию): Быстро создается, не хранит данные физически. Запрос выполняется каждый раз, когда вы к представлению обращаетесь. Идеально для стейджинг-слоя.
* **`table`**: Медленнее создается, так как физически копирует все данные. Зато запросы к такой таблице выполняются очень быстро. Идеально для финальных витрин данных.
* **`incremental`**: Умный `table`-режим, который позволяет дописывать в таблицу только новые данные, а не перестраивать ее целиком.
* **`ephemeral`**: "Виртуальная" модель, которая не создается в базе данных, а используется как CTE (Common Table Expression) в других моделях.

---

## Практика

### Задача 2.1: Объявляем источник

Давайте "расскажем" dbt о нашей таблице с поездками.

1.  Создайте (или откройте) файл `models/schema.yml`.
2.  Вставьте в него следующий код. Замените `public` на имя вашей схемы, если оно отличается.

```yaml
version: 2

sources:
  - name: raw_taxi_data # Придумываем общее имя для группы источников
    schema: public # Схема в Postgres, где лежит таблица
    tables:
      - name: raw_taxi_trips # Точное имя таблицы в Postgres
```

---

### Задача 2.2: Создаем первую стейджинг-модель

1.  Создайте файл `models/staging/stg_yellow_tripdata.sql`.
2.  **Цель:** выбрать данные из источника, переименовать столбцы в `snake_case` и сделать базовый кастинг типов. Это "очищенная" копия сырых данных.
3.  Вставьте в него следующий SQL-запрос:

```sql
-- models/staging/stg_yellow_tripdata.sql

{{
  config(
    materialized='table'
  )
}}

select
    tpep_pickup_datetime::timestamp as pickup_datetime,
    tpep_dropoff_datetime::timestamp as dropoff_datetime,
    passenger_count::int,
    trip_distance,
    "PULocationID" as pickup_location_id,
    "DOLocationID" as dropoff_location_id,
    payment_type,
    fare_amount,
    tip_amount,
    total_amount
from {{ source('raw_taxi_data', 'raw_taxi_trips') }}
```

**Запускаем!**
Выполняем команду dbt run для создания нашей модели:

```
docker compose exec dbt dbt run
```
Проверяем: Убедитесь, что в вашей целевой схеме в Postgres появилась view с именем stg_yellow_tripdata. Результат тот же, что и раньше, но теперь мы управляем типом объекта в базе данных прямо из кода модели.

---

## Полезеные ссылки и документация

* [**Sources**](https://docs.getdbt.com/docs/build/sources)
* [**Модели**](https://docs.getdbt.com/docs/build/sql-models)
* [**Виды материализации моделей**](https://docs.getdbt.com/docs/build/materializations)
* [**Инкрементальные стратегии**](https://docs.getdbt.com/docs/build/incremental-strategy)